## 开发文档

### 首页

appkey:

```js
O7BMoq5Sm5MOZXuZ
zmSPVc0UqzqlqeMM
Uhzl0bGiikOrJrcr
bhAAMYFnpUtUoa1X
```



#### **小程序分层结构:**

```md
页面js -数据绑定
view层 业务逻辑层 桥梁
Model层 处理业务
寻找业务对象 重要
```

首页发送请求定义成**model处理业务**，然后就是页面js接收数据

**封装原生`wx,request`  使用promisic工具方法**

```js
class Http{
    static async request({
        url,
        data,
        method='GET'
    }){
        return await promisic (wx.request)P{
            url:`${config.basesURL}${url}`,
                data,
                method,
                header:{
                    appkey:config.appkey
                }
        }
    }
}
```

接下来每次请求只需要去 `Http.request({`url,data，method`})`即可

#### 具体技巧学习

##### **消除图片自带间距 `display:flex`**

##### **类不能保存数据的状态 ，只有类的对象才能保存数据和状态**

```js
Theme.a=1
Theme.a=2
// 改变了状态
const t = new Theme()
t.a =1
const t2 =new Theme()
t2.a =2
// 即保存了数据又保存了状态
```



#####  **封住请求的theme方法**

```js
import { Http } from '../utils/http'
class Theme {
  static ThemeA = 't-1'
  static ThemeB = 't-2'
  static ThemeC = 't-3'
  static ThemeD = 't-4'
  // 用类对象存储数据 改写方法  避免请求多次服务
  themes = []
  async getHomeThemes() {
    const res = await Http.request({
      url: '/theme/by/names',
      data: {
        names: `${Theme.ThemeA},${Theme.ThemeB},${Theme.ThemeC},${Theme.ThemeD}`,
      },
    })
    this.themes = res.data
  }
  // 直接获取locationA LocationB 保证调用方的请求代码简洁
  async getThemeA() {
    return this.themes.find((t) => t.name === Theme.ThemeA)
  }
  async getThemeB() {
    return this.themes.find((t) => t.name === Theme.ThemeB)
  }
  async getThemeC() {
    return this.themes.find((t) => t.name === Theme.ThemeC)
  }
  async getThemeD() {
    return this.themes.find((t) => t.name === Theme.ThemeD)
  }
  static getHomeLocationESpu() {
    return Theme.getThemeSpuByName(Theme.ThemeB)
  }

  static getHomeThemeCSpu(){
    return Theme.getThemeSpuByName(Theme.ThemeC)
  }
  static async getThemeSpuByName(name) {
    const res =await Http.request({
      url: `/theme/name/${name}/with_spu`,
    })
    return res.data
  }
}

export { Theme }

```

##### **页底提示其实只有两种状态**

> 加载中（当滑动到底部就显示 常驻状态） 所以再最外层 直接设置`show="{{true}}"`
>
> 没有更多数据了 此时没有更多数据了，设置loading的type和end-text即可







##### **scroll-view组件使用**

```md
spu 一件商品 
sku 一件商品有多种颜色 库存 种类 等等
```

将某些数据抽象为不同的模型：例如热卖榜单的数据就可以视为轮播图

**scroll-view组件** 定义为这样的结构较好

```html
<scroll-view scroll-x="{{true}}">
<view class="inner">
    <block wx:for="{{spuList}}">
    <view class="item">
        <image></image>
        <view class="desc">
            <view>title</view>
            <view>price</view>
        </view>
        </view>
    </block>
    </view>
</scroll-view>
```

控制inner的样式

```css
.inner{
    display:flex;
    flex-direction:row
}
```

##### **点击动画- view组件的`hover-class`,`hover-stay-time`设置动画时间(ms)**

```css
.react-hover{
  position: relative;
  top: 3rpx;
  left: 3rpx;
  box-shadow: 0px 0px rgba(0,0,0,.1)inset;
}

```



##### **瀑布流布局和封装分页加载API**

智能推荐

```js
点击过后 用标签记录数量 然后根据标签随机分配
```

分页数据： 正在加载 loading 加载完成  没有更多数据了

分装请求分页的API

```js
// 定义属性 保持状态要用类对象属性
// 获取更多数据状态  1.getLocker 当别的请求正在执行 不能发送请求
2. request 3. 释放locker
```



封装 req

```js
// 考虑两种情况 
1. url = '/v1/spu/latest?start=0&count=10'
2. url已经有了query '/v1/spu/latest?other=1'

拼接方法
url = this.url
if(url.indexOf('?')!==-1){
    url += '&'+params
}else{
    url += '?'+params
}
```

**正式封装**

```js
class Paging{
  // 1. 初始化属性 url-原始请求地址 locker是否上锁 req请求的对象 accumlator历史请求数组
    url
    locker= false
    start
    count
    req
    moreData = true
    accumlator=[]
// 初始化
	constructor(req,count=10,start=0){
        this.req = req
        this.url = req.url
        this.count = count
        this.start =start
    }
// 定义业务过程
getMoreData(){
    if(!this.getLocker()){
        return
    }
    this.getData()
    this._releaseLocker()
}

// 封装 getData()

getData(){
    const req = this._getCurrentUrl()
    const Paging = Http.request(req)
    if(!paging){
        return null
    }
    if(paging.data.total === 0){
        return {
            empty:true,
            moreData:false,
            items:[],
            accumulator:[]
        }
    }
    this.moreData = this._getMoreData(paging.data.total_page,paging.data.page)
    if(this.moreData){
        this.start += this.count
    }
    this.accumulator = this._getaccumlator()
    return {
        empty:false,
        moreData:this.moreData,
        items:paging.data.items,
        accumulator:this.accumulator
    }
    
}
// 获取拼接后的地址
_getCurrentUrl()// 上面提到
// 是否有更多数据
_getMoreData(totalPage,page){
    return page<totalPage-1
}
// 拼接items
_getaccumlator(items){
    this.accumulator = this.accumulatro.conctat(items)
}
}
```

**调用数据就需要封装一个单独的模型 来实例化paging对象 在通过对象调用方法1**

**瀑布流传递数据**

```js
1. 定义抽象节点 接收的属性名一定要定义为data
2. 传递数据
 wx.lin.renderWaterFlow(data.items)  data为数组 
3. 编写节点
```

#####  **使用wxs **
处理价格是打折还未打折 打折的原价划线 未打折不划线

```js
function mainPrice(price,discount_price){
    if(!discount_price){
        return price
    }else{
        discount_prce
    }
}
function slashPrice(price,discountpirce){
  if(discountpirce){
    return price
  }else{
    return 
  }
}
```

##### **动态计算宽高 是图片自适应高度或宽度**

```js
<image bind:Load="onImgLoad" style="width:{{w}}rpx;heiht:{{h}}rpx">
onImgLoad(event){
    const {width,height} = event.detail
    this.setData({
        w:340rpx;
        h:340rpx*height/width
    })
}
// 或者直接使用mode
```
##### 间隔轮播设置
> 采坑：定义组件一定在index.json加上:`components:true`
>
> 小程序wxs导出function 不能再module.exports={}简写
>
> 轮播图设置间距  `previous-margin``next-margin` 

样式代码

```css
1. swiper居中
2. image设置为块状
3. 设置swiper属性
.swiper{
  height: 360rpx;
  width: 100%;
  background: #ffffff
}
swiper-item{
 text-align: center
}

.swiper-img{
  display: inline-block;
  width: 610rpx;
  height: 360rpx;
  border-radius: 10rpx
}
```

##### **小程序路由传参**(绑定属性值，传递属性值)

```js
1. 设置传递参数属性 dom上绑定data-属性名
拿到属性 e.currentTarget.dataset.
2. 绑定点击事件跳转路由
wx.navigateTo({
    url:`/pages/detail/index?pid=${pid}`
})
拿到参数： 子路由通过
onLoad:function `options.pid`拿到传递的参数


业务组件可以这样写 但考虑到通用性 组件里面不应该包含路由跳转事件
所以可以向外触发事件 有父组件进行路由跳转
this.triggleEvent('changeNavigate',{params})
```

### SKU SPU

> SPU(Standard Product Unit) 标准化产品 -商品
>
> SKU(Stock Keeping Unit) 库存量单位 -商品的规格，单品

![1586505050343](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586505050343.png)

这里的SPU-这台电脑的信息，SKU-下方可选择配置颜色等



#### **规格名 规格值**

```markdown
规格:
颜色: 暗夜绿 黑色
运存: 64GB 256GB 
版本 : 全网通 电信

规格名：颜色
规格值 : 暗夜绿 黑色
```

> 变量命名技巧：
> 尽量不要加前缀领域进行命名 抛开sku 寻找特定名字

> 单个规格为一个对象 一个规格组合是一个对象

#### sku状态判断：

> sku状态判断就像是字典里面查字典，如果查不到组合就是不可选状态，如果有就是可选状态

将skuList抽离成一个矩阵 然后进行旋转

```markdown
金属灰 七龙珠 小号s
青芒色 灌篮高手 中号M
青芒色 圣斗士 大号L
橘黄色 七龙珠 大号L
```

#### 实现矩阵转置的几种方法

- **遍历二维数组**

首先拿到二维数组

```js
_createMatrix(){
    const m = []
    this.sku_list.forEach((sku)=>{
        m.push(sku.specs)
    })
}
```

创建`matrix`对象,在对象中定义遍历方法

```js
class Matrix{
    m
    constructor(m){
        this.m = m
    }
    // 获取行列数
    get row(){
        return this.m.length
    }
    get col() {
        return this.m[0].length
    }
    // 回调传递参数
   forEach(callback){
       // 先遍历列 在遍历行可以拿到旋转90度的数组
      for(let j=0;j<this.col;j++){
          for(let i=0;i<this.row;i++){
              const element = this.m[i][j]
              callback(element,i,j)
          }
      }
   }
}
```

遍历过程中判断当前列 然后创建fence对象并插入数组

```js
// 遍历拿到所有的element 然后初始化fence
  initFence() {
    const matrix = this._createMatrix(this.skuList)
    let CurrentJ = -1
    const fences = []
    matrix.forEach((element, i, j) => {
      // 首先判断当前列是否与currentJ相等
      if (CurrentJ !== j) {
        // 零列开始  然后将每列元素赋给fences 列变为行
        CurrentJ = j
        // 创建fence对象
        const fence = new Fence()
        fences[CurrentJ] = fence
      }
      // 将fence对象的title传入数组
      fences[CurrentJ].pushValuetitles(element.value)
    })
    console.log(fences);
      // [['金属灰',...],['七龙珠',..],[‘小号s’..]]
      
  }
```

- **定义矩阵转置方法实现**

  ```js
  // 矩阵转置
    transpose() {
      let desArray = []
      for (let j = 0; j < this.col(); j++) {
        // 定义行数组
        desArray[j] = []
        for (let i = 0; i < this.row(); i++) {
          // 行数组元素 和原来的i，j位置互换
          desArray[j][i] = this.m[i][j]
        }
      }
      return desArray
    }
  ```

  然后fence-group拿到转置后的矩阵 遍历转置矩阵

  ```js
  const AT = matrix.transpose()
  let fences = []
  AT.forEach(specs=>{
      const fence = new Fence(specs)
      // 初始化fence
      fence.init()
      fences.push(fence)
  })
  ```

  fence则遍历每一个specs数组

  ```js
  init(){
      this.specs.forEach(spec=>{
          const cell = new Cell(spec)
          this.cells.push(cell)
      })
  }
  ```

  cell()

  ```js
  class cell{
      title
      constructor(spec){
          this.title =spec.value
      }
  }
  ```

  这样就可以充分利用面向对象的作用 先实例化 将数组当做属性传入,最后返回一个这样的数组 属性充当数组作为对象元素

  

![1586610274779](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586610274779.png)

**对cell去重**

```js
  // 去重cell  some，every 区别是some只要有一个条件满足表达式返回true every需要全部的元素
      const existed = this.Cells.some(c=>{
        return c.id === spec.value_id
      })
      if(existed){
        return 
      }
```

#### SKU算法

##### 核心思路

拿到的fences

![1586615412711](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586615412711.png)

sku算法的目的是为了体验性，

算法的核心:`确定禁用状态` 

三种状态: `选中`  `未选` `禁用`

![1586616422555](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586616422555.png)

确认禁用状态的总体思路:

> 首先，所有规格值都是可选的，当用户选择一个规格值时，确认青芒色是否和七龙珠是否在一个`sku路径`，如果在就是一个路径,如果不在就禁用。然后再选择灌篮高手,确定下一个小号s是否存在，确定它的禁用状态。

可能存在的问题:

> 点击青芒色 先确认青芒色 尺码 六个路径是否已存在 存在可选，不存在则禁用。然后当选择到灌篮高手时，再重新计算青芒色+灌篮高手+尺码的三条路径是否存在，不存在禁用 ，`还有反向选择`。todo：优化算法 编写代码

**已选规格的改变 都要计算所有的规格**

1. 已存在的sku路径
2. 待确认的sku路径

#### 已存在的sku路径

创建一个judger类 ,传入属性`fence-group` 然后对spu循环进行处理

>  这里我们主要针对code这个字段进行处理

```js
this.spu.forEach(s=>{
    const Skucode = new SkuCode(s.code)
})
```

##### code类

```js
1.对code进行分割
// 2$1-45#3-9#4-14  
const SpuIdAndSpec = this.code.split('$')
this.SpuId=SpuIdAndSpec[0]
// 对剩下的规格进行所有可能的组合
const SpecArray = SpuIdAndSpec[1].split('#')
for(let i =1;i<SpecArray.length;i++){
    // 组合所有可能
  const result = combine(SpecArray,i)// 得到的结果是二维数组
  result.map(r=>{
      return r.join('#')
  })
    // 用# 连接所有的二维数组元素
}

```

![1586677237138](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586677237138.png)

然后再把所有的一维数组都**连接**到定义的空数组

```js
 this.seqments= this.seqments.concat(joinedResult)
 this.pathDirt=this.pathDirt.concat(SkuCode.seqments)
```

**最终就会得到一个数组包含所有的路径**

`["1-45", "3-9", "4-14", "1-45#3-9", "1-45#4-14", "3-9#4-14", "1-45#3-9#4-14", "1-42", "3-10", "4-15", "1-42#3-10", "1-42#4-15", "3-10#4-15", "1-42#3-10#4-15", "1-42", "3-11", "4-16", "1-42#3-11", "1-42#4-16", "3-11#4-16", "1-42#3-11#4-16", "1-44", "3-9", "4-14", "1-44#3-9", "1-44#4-14", "3-9#4-14", "1-44#3-9#4-14"]`

这样就获取到了所有的已存在的`sku路径`

#### 待确认路径

先定义cell的状态:可选 待选 选中

> 采坑：wxs文件不能引入别的js文件

##### **小程序开启跨越组件冒泡** :`bubbles:true,composed:true`

```js
this.triggerEvent('cellTap',{cell:this.propertes.cell},{bubbles:true,composed:true})
```

##### 传递cell给relma 然后计算所有可选的状态

##### **重要的对象**

```js
cell
fences
Cells
FenceGroup
```

**cell**: 一个sku规格  对象

![1586760453456](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586760453456.png)

**fences:** 一组Fence对象 ，一个Fence对象（Cells数组,specs转置后的原数组，title，titleid）

<img src="C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586760590859.png" alt="1586760590859"  />

**Cells** : 一个规格名下的 一组规格值

![1586760649321](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586760649321.png)

**FenceGroup** : 包含 fences，skuList，spu的对象

![1586760696975](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586760696975.png)



**引用类型:**

```js
const a ={c:1}
const b = a
b.c =2
a.c =2
```

**规律**

> 1. 当前的cell不需要判断潜在路径
> 2. 对于某个cell，它的潜在路径是自己加上其他已选中的cell
> 3. 不需要考虑当前行的cell是否已选

#### 主体逻辑方法

主要分为两个部分: 改变点击后的状态 ，改变其他元素的状态

> 首先judge类里面传递cell对象，cell对象是子cell组件传递过来的参数的spec对象，
>
> 然后加入status属性.
>
> 编写judge方法 传递 `cell`,`x`,`y`

##### 改变元素当前的状态，来控制样式的改变 

```js
  changeCurrentCellStatus(cell, x, y) {
    if (cell.status === CellStatus.WAITING) {
      this.fenceGroup.fences[x].Cells[y].status = CellStatus.SELECTED
      // pending数组添加一个规格
      this.SkuPending.insertCell(cell, x)
    } else {
      if (cell.status === CellStatus.SELECTED) {
        this.fenceGroup.fences[x].Cells[y].status = CellStatus.WAITING
        this.SkuPending.removeCell(x)
      }
    }
  }
```

> **SkuPending对象**：保存从waiting变为选中状态的元素的对象,每一行必须只能有一个选中元素，后续选中状态需要用isSelected判断
>
> ```js
> insertCell(cell, x) {
>     this.pending[x] = cell
>   }
>   removeCell(x) {
>     this.pending[x] = null
>   }
>   findSelectedCell(x){
>     return this.pending[x]
>   }
>   isSelected(cell,x){
>     const selectCell = this.pending[x]
>     if(!selectCell){
>       return
>     }
>     return cell.id === selectCell.id
>   }
> ```
>
> 

##### 遍历所有的节点，查找每个元素的潜在路径(待确定的路径)

1. `fence-group`类添加遍历`cell`方法

```js
eachCell(cb){
    for(let i =0;i<this.fences.length;i++){
      for(let j = 0; j<this.fences[i].Cells.length;j++){
        const cell = this.fences[i].Cells[j]
        cb(cell,i,j)
      }
    }
  }
回调函数中执行查找潜在路径方法 就是遍历循环
```

2. 查找节点的所有待确认路径

   > 首先遍历所有的行 拿出pending的已选中的元素 ,如果是当前行，cellCode就拼接出来，如果是当前行当前选中元素就不做任何处理。否则如果是其他行，选中状态就拼接已经选中的cellCode
   >
   > ```js
   > 举例： 选中的cell为 1-45 0，0
   > 
   > i = 0 ,selected = pending[0]:1-45, cellCode = 1-45 return 
   > 
   > i = 1,selected =pending[1]：null, return null 
   > 
   > i = 2,selected =pending[1]：null, return null 
   > 
   > i = 3,selected =pending[1]：null, return null 
   > 
   > 上面是 x=0，y=0时的遍历 直接是return了，就是没有执行
   > 
   > 然后  x=0,y=1
   > 
   > i=0 selected = 1-45,cellCode = 1-44  return
   > 
   > i=1 selected =null return null
   > 
   > ....    这里就是大致的循环思路
   > ```
   >
   > 

   

   ```js
   _findPotentialPath(cell, x, y) {
       // 查找潜在路径
       //* 1.获取当前行已选元素的潜在路径
       const joiner = new Joiner('#')
       for (let i = 0; i < this.fenceGroup.fences.length; i++) {
         const selected = this.SkuPending.findSelectedCell(i)
         // 如果是当前行
         if (x === i) {
           const cellCode = this._getCellCode(cell.spec)
           // 如果当前行的元素已经被选中 就不做任何处理  该判断存在bug，可能同行会存在几个已选元素 
           if (this.SkuPending.isSelected(cell,x)) {
             return
           }
           // 拼接器
           joiner.join(cellCode)
         } else {
           // 其他行
           if (selected) {
             // 如果其他行有选中的，就拼接当前行的和其他行已选中的路径
             const selectedCode = this._getCellCode(selected.spec)
             joiner.join(selectedCode)
           }
         }
       }
       return joiner.getStr()
     }
   ```

   打印出来的潜在路径

   ![1586858352010](C:\Users\努力中的杨先生\AppData\Roaming\Typora\typora-user-images\1586858352010.png)

3. 通过查找是否已存在的路径中存在潜在路径，更改元素状态

   ```js
   this.fenceGroup.eachCell((cell, x, y) => {
         // 在遍历所有节点的回调中拿到潜在路径 九个节点遍历循环九次 每次都去寻找该节点的潜在路径
         const path = this._findPotentialPath(cell, x, y)
         if(!path){
           // 不去更改当前行已选元素的状态
           return
         }
         const isIn = this.pathDirt.includes(path)
         // 如果存在 就置为waiting 否则禁用 如果是当前行的已选元素就不用去查找
         if (isIn) {
           this.fenceGroup.fences[x].Cells[y].status = CellStatus.WAITING
         } else {
           this.fenceGroup.fences[x].Cells[y].status = CellStatus.FORBIDDEN
         }
       })
   ```


#### 确定默认sku状态

   首先获取到sku，然后将specs数组初始化cell对象push进pending数组,

设置默认的规格的状态,首先定义一个方法（传入cellId就能改变cell的状态）

```js
changeCellStatus(cellID,status){
    this.eachCell((cell)=>{
        if(cell.id === cellID){
            cell.status = status
        }
    })
}
```

然后在初始化默认sku之后，遍历skuPending改变fences里面的cells的状态.

```js
_setdefaultSkuStatus(){
    this.SkuPending.pending.forEach(cell=>{
      this.fenceGroup.eachCell(((c)=>{
        if(c.id === cell.id){
          c.status = 'selected'
        }
      }))
    })
  }
```

> 这里不需要调用改变当前行的状态的方法`changeCurrentCellStatus()`

#### 选择联动

有默认sku 无默认sku'情况

##### 选择了完整的sku情况

```js
isIntact(){
    // size 默认情况下的规格个数 实例化skuPending时传入
    if (this.size !== this.pending.length) {
      return false
    }
    // 可能存在pending数组部分元素是undefined 所以判断一下
    for (let i = 0; i < this.pending.length; i++) {
      if (this._isEmptyPart(i)) {
        return false
      }
    }
    return true
}
```

然后再realm下初始化fences设置data 是否是完整的sku

> 当用户选择了完整的路径 文本显示为 已选择 路径 ，当用户没有选择完整的路径，文本显示为：请选择下一个规格的名称，无规格则都不显示

##### 数据渲染

>首先需要定义一个方法，当用户点击cell时，拼接出已经确定的skuCode，然后通过这个skuCode找出`sku_list`里面的符合条件的sku。

`judger`中定义获取sku方法

```js
  // 通过确定的SkuCode确定Sku
  getDetermineSku(){
    const SkuCode = this.SkuPending.getSkuCode()
    const sku= this.fenceGroup.getSkuBySkuCode(SkuCode)
    return sku
  }
```
`skuPending`获取当前已确定`skuCode`，需要确保`pending`数组存储的是cell模型对象

```js
getSkuCode(){
const joiner = new Joiner()
this.pending.forEach(cell=>{
    const cellCode = this._getCellCode()
    joiner.join(cellCode)
})
    return joiner.getStr()
}

// 方法定义在fencegroup中
getSkuBySkuCode(code){
    const SkuCode = `${this.spu.id}$${code}`
    this.spu.sku_list.find(s=>{
        return s.code === SkuCode
    })
}
```

**没有选完sku，不用渲染，等到选完sku就渲染**

在`onCellTap`方法里面完成Sku渲染,只有在选择完成完整的路径，才改变sku的绑定

 ```js
 const SkuIntact = judger.SkuPending.isIntact()
 if(SkuIntact){
     const Sku = judger.getdetermineSku()
     this.bindSku(Sku)
     this.bindTipdata()
 }
 ```

 这样就完成了选择完路径，上方信息的重新渲染

 **处理当前选择的文本**

需要确定完整的路径的sku路径的`value` ，还要确定不完整情况下的路径中缺失的`specKey`

```js
// 获取当前确定的sku的value 返回的还是数组不需要处理格式
  getCurrentSpecValue(){
    const value = this.pending.map(cell=>{
      // 可能为undefined,就用三元表达式
      return cell? cell.spec.value:null
    })
    return value
  }
  // 获取缺失的key的下标数组 然后再judge获取道fences下index的title
  getMissingSpecKeyIndex(){
    keyIndex = []
    for (let i = 0; i < this.size; i++) {
     if(!this.pending[i]){
      keyIndex.push(i)
     }
    }
    return keyIndex
  }
```
然后通过`this.setData`绑定数据显示在text文本即可
> 双花括号直接可以显示数组

#### 无规格

无规格判断标准:`只有一个sku，没有规格`

```js
static isNoSpec(spu){
    if(spu.sku_list.length ===1 && spu.sku_list[0].specs.length ===0){
      return true
    }else{
      return false
    }
 }
```

*无规格情况下只有一个sku*


```js
if(Spu.isNoSpec(spu)){
    this.setData({
        NoSpec:true
    })
    this.bindSku(spu.sku_list[0])
}
```

自此，完成了所有的`SKU`的算法，选择，联动。

### 详情页

#### 货物状态

```js
1.点击cell 引起缺货状态
2.点击数量选择器 引起缺货状态
3. 初始化的时候也要 引起缺货状态

```

```js
  // 判断是否无货
    onTapcount(e){
      const count = e.detail.count
      this.setData({
        count
      })
      const sku = this.data.judger.SkuPending.getDetermineSku()
      this.setOutOfStock(sku.stock,count)
    },
    isoutOfStock(stock, count) {
      return stock < count
    },
    setOutOfStock(stock,count){
      this.setData({
        outStock:this.isoutOfStock(stock,count)
      })

    },
```

> 采坑：自定义组件无法使用全局样式 ，只能进行引入wxss文件

> 编程能力:动机应该是为了解决问题。



#### 可视规格

> 确认可视规格，根据管理员设置的可视规格名，去往fence中添加那个fence数组

1. `fence-group`模型定义判断方法

   ```js
   _hasSktechFence(){
       return this.spu.sktech_spec_id ? true:false
   }
   _isSktechFence(fenceId){
       return this.spu.sktech_spec_id === fenceId ?true:false
   }
   ```

2. `fence`中定义设置可视规格图片的方法

   ```js
   setFenceSktech(skulist){
       // cells 中查找出包含cell的code码的sku
       this.Cells.forEach(c=>{
           this.setFenceImg(c,skulist)
       })
   }
   
   setFenceImg(cell,skulist){
       const SkuCode = cell._getCellCode()
       const Sku = this.skulist.find(s=>s.code.includes(SkuCpde))
       if(Sku){
           cell.img = Sku.img
       }
   }
   ```

   解决页面滚动条高度覆盖底部`tabbar`问题
   
   > 计算出页面的可视高度 ，将外层view替换成`scroll-view`,然后给一个高度

### 分类

#### 解决滚动条问题

左侧`segment`滚动条处理，不处理滚动条的话页面会出现滚动条，体验效果差

```js
计算高度 
关闭均分模式
赋值给l-segment一个高度
```

> 原理就是设置`scroll-view`的高度，滚动条可以控制，防止盖住自定义`tabbar`或者解决隐藏页面的滚动条

动态换算 在不同机型下将`px`转换为`rpx`

> 1. 计算`rate` 小程序的宽度都是`750rpx`,高度通过`wx.getSystemInfo`回调可以获取到，机型的宽度`res.screenWidth`,`rate=750/res.screenWidth`
> 2. 将`px`数值乘以`rate`即可计算出`rpx`数值

```js
const getSystemHeight =async function(){
  const res = await promisic(wx.getSystemInfo
  )()
  return {
    // 可视区域 除去tabbar和导航条
    windowHeight: res.windowHeight,
    windowWidth: res.windowWidth,
    // 设备屏幕高宽
    screenHeight: res.screenHeight,
    screenWidth: res.screenWidth
  }
}
// 获取可用高度 并转换为rpx
const getWindowHeight = async function(){
  const res = await getSystemHeight()
  const windowHeight = px2rpx(res.windowHeight)
  return windowHeight 
}
```



计算`segement`高度，然后赋值给组件即可

```js
// 设置segement的高度 高度为可用高度减去搜索框 再减去padding
   async setSegementHeight(){
    const segementHeight =  await getWindowHeight()-82
    this.setData({
      segementHeight:segementHeight
    })
  },
```

#### 一级分类

首先一般电商获取分类数据都是一次性加载全部的数据的，只有那些较大的电商需要点击一级分类然后分别加载不同的二级分类数据。

确定好一次性加载后，在`model`下定义`categories`模型,该模型下需要定义三个方法，同样应该是保存状态的方法

```js
  roots = []
  subs = []
  async getHomeCategory(){
   const res = await Http.request({
      url:'/category/all'
    })
    this.roots = res.data.roots
    this.subs = res.data.subs
  }
  // 获取roots
  getCategoryRoots(){
    return this.roots
  }
  // 根据rootID获取subs
  getSubsByRootID(rootID){
    // 切换时传递的ID是字符型 需要转换一下类型
    return this.subs.filter(sub=>sub.parent_id == rootID)
  }
  // 根据rootID获取root
  getRootByRootID(rooID){
    return this.roots.find(root=>root.id == rooID)
  }class Categories {
  roots = []
  subs = []
  async getHomeCategory(){
   const res = await Http.request({
      url:'/category/all'
    })
    this.roots = res.data.roots
    this.subs = res.data.subs
  }
  // 获取roots
  getCategoryRoots(){
    return this.roots
  }
  // 根据rootID获取subs
  getSubsByRootID(rootID){
    // 切换时传递的ID是字符型 需要转换一下类型
    return this.subs.filter(sub=>sub.parent_id == rootID)
  }
  // 根据rootID获取root
  getRootByRootID(rooID){
    return this.roots.find(root=>root.id == rooID)
  }
}
```

然后再`category`js文件中初始化一级分类和二级分类，在这之前需要定义一个模拟的默认的一级分类ID,这里使用`2`

```js
async initCategoryData(){
   const categories = new Categories()
   this.data.categories = categories
    await categories.getHomeCategory()
    const roots = categories.getCategoryRoots()
    // 获取默认的一级分类 和二级分类
    const defaultRoot = this.getDefaultRoot(roots)
    const defaultSubs = categories.getSubsByRootID(defaultRoot.id)
    this.setData({
      roots,
      currentSubs:defaultSubs,
      currentBannerImd:defaultRoot.img
    })
    this.setSegementHeight()
  },
  getDefaultRoot(roots){
    let defaultRoot = roots.find(r => r.id === this.data.defaultID)
    if (!defaultRoot) {
      defaultRoot = roots[0]
    }
    return defaultRoot
  },
```



#### 二级分类

利用`宫格组件`快速搭建二级分类组件,然后接受的数据由`分类`页面传递

要传递的数据有两个 `sunbs` `bannerImg`

**当选项卡进行** 进行切换时，监听`linchange`事件拿到`activeKey`，然后通过不同的key来设置当前的值

```js
 // 切换选项卡
  changeTabs(event){
    // 监听事件拿到key
    const key = event.detail.activeKey
    const currentRoot = this.data.categories.getRootByRootID(key)
    const currentSubs = this.data.categories.getSubsByRootID(currentRoot.id)
    this.setData({
      currentSubs,
      currentBannerImd:currentRoot.img
    })
  },
```

这样就完成了分类页面的

### 搜索

#### 通用历史搜索类

```js
使用单例模式
1. 设置最大值
2. 要去重
3. 提供三个方法 保存 获取 清除
class HistoryCkeyWord{
    static MAX_ITEM_COUNT = 20
	keywords = []	
constructor(){
    // 初始化keywords
    this.keywords = this._getLocal()
}
    save(keyword){
        // 去重
        const items = this.keywods.filter(k=>k === keyword)
        if(items.length > 0){
            return
        }
        // 长度限制 超长踢旧push进去新的
        if(this.keywords.length >= MAX_ITEM_COUNT){
            this.keywords.pop()
        }
        this.keywords.unshift()
        this.refreshLocal()
    }
    get(){
        return this.keywords
    }
    clear(){
        this.keywords = []
        this.refreshLocal()
    }
	refreshLocal(){
        wx.setLocalStorage(key,this.keywords)
    }	
getLocal(){
    const keywords = wx.getLocalStorage(key)
    if(!keywords){
         wx.setLocalStorage(key,[])
        return []
    }
    return kewwords
}
}
```

js`单例模式`

构造函数中加入下面代码

```js
constructor(){
    if(typeof 类名.instance === 'object'){
        return 类名.instacne
    }
    // 保存类对象
    类名.instance = this
    return this
    // 永远返回this
}
```

#### 搜索结果

两个地方要显示结果：1.输入搜索词 2.点击标签

#### 考虑的情况

```js
需要考虑的点
空数据
空格很多
空搜索结果
加载中
点击标签搜索
```

输入搜索词回车后和点击标签都要进行搜索

```js
async onConfirm(event){
    // 初始化search 显示结果页
    this.setData({
      search:true
    })
    // 获取输入框值 如果是点击标签输入框的值更换
    const keyword = event.detail.value || event.detail.name
    if(keyword === event.detail.name){
      this.setData({
        value:keyword
      })
    }
    // 如果没有值 或者有空格
    if(!keyword){
      wx.showToast({
        title: '请输入关键词',
        icon: 'none',
        duration:2000
      })
      return 
    }
    if(!keyword.trim()){
      console.log('全是空格')
      wx.showToast({
        title: '请输入正确的关键词',
        icon: 'none',
        duration:2000
      })
      return
    }
    // 保存历史
    history.save(keyword)
    this.setData({
      historytags:history.get()
    })
    wx.lin.showLoading({
      type:'flip',
      color:'#157658',
      fullScreen:true
    })
    // 搜索
    const SearchPaging = Search.searchKeywords(keyword)
    const data = await SearchPaging.getMoreData()
    if(!data){
      return
    }
    // 如果是空结果就显示空商品状态页
    wx.lin.renderWaterFlow(data.items)
    if(!data.items.length){
      this.setData({
        status:true
      })
    }
    wx.lin.hideLoading()
  },
```

> 标签的`dom`上要设置`name`属性为标签的文字，然后监听点击事件再进行搜索关键词,搜索`API`也是分页的，所以创建一个`paging`对象实例，然后调用方法。

用`hottags`和`historytags`记录标签，当`historytags`长度不为零才显示. 显示结果复用`瀑布流组件`

这样就完成了搜索页

### 专题详情页

